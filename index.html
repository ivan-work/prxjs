<html>
<head>
  <meta charset="utf-8"/>
  <title>PRXJS</title>
  <link href="css/fonts/fonts.css" rel="stylesheet"/>
<link href="css/main.css" rel="stylesheet"></head>
<body>
<div class="reveal">
  <div class="slides">
    <section data-menu-title="Introduction"><section data-timing="20"><h1>Anatomy of RxJS</h1><aside class="notes"><p>Hello!</p><p>My name is Ivan Naimark, I am react/nodejs developer here, at Grid Dynamics.</p><p>Today I'd like to talk about RxJS.</p></aside></section><section data-timing="60"><h2>My story</h2><ul><li>RxJava was cool&nbsp;<img src="img/doge.png" height="100" valign="middle"></li><li class="fragment">AngularJS / React doesn't have RxJS</li><li class="fragment">Pet-projects<br><!--img.fragment.replace-in-out(src='img/pepe.png' height=400)--><img class="fragment" src="img/stackoverflow.png" height="400"></li></ul><!--.fragment.center: img(src='img/stackoverflow.png' width=800)--><aside class="notes"><p>Let me tell you my story:</p><p>So my first encounter with Rx happened when I was Android developer and it was RxJava</p><p>I'm not sure what's happening in mobile right now, but back in my days it was very verbose.</p><p>You were writing abstract factories of thread pools, do all the stuff imperatively, painfully switch threads, so when I went to a project with RxJava I liked it.</p><p>even though it burned my brains a bit, I took a notice - wow, reactive style is cool, but hard</p><p>Then I switched to javascript, learned Angualr 1 and React and kinda forgot about it.</p><p>When angular 2 came out I decided to skip it because I like React. Not going to holy war, it's just me</p><p>However, I like to make hobby projects, like bots, games, fun stuff and usually, the logic in them is a bit more complex than in our enterprise webapps.</p><p>y know, show this table, show that table, if something is wrong, blame backend :)</p><p>So, for my next multiplayer game I've decided to use RxJS, because events, async stuff and I wanted actors all over the place...</p><p>and then it hit me hard.</p><p>SPACE</p><p>It was so hard to manage it and actually make it do what I want. I'm talking about logic like this - real screenshot of my question</p><p>I won't go explaining what I'm trying to achieve here, the main point is -</p><p>when I went beyond simple requests and tried to utilize all power to achieve what I want - it was hard.</p><p>And all the online resources didn't help me - it were either introductions or, like, deep dives that even show you how to create custom operators</p><p>but they were not explaining why its working and how it's happening.</p><p>therefore this presentation was born - I decided to deep dive myself and go to the sources.</p></aside></section><section data-timing="30"><h2>Introductions</h2><ul><li>.maps and .subscribes are fun!</li><li class="fragment">.takeUntil is less fun:<div class="massive"><div class="pre"><code>someDataStream$.pipe(
  takeUntil(componentUnmount$),
  merge(Rx.fromEvent(...), Rx.fromEvent(...))
)</code></div></div></li><li class="fragment">reading this is not fun at all:<code class="hljs">Maps each source value to the given Observable innerObservable regardless of the source value, and then flattens those resulting Observables into one single Observable, which is the output Observable.

The output Observables emits values only from the most recently emitted instance of innerObservable.

<div class="right small">Â© .switchMapTo API documentation</div></code></li></ul><aside class="notes"><p>Of course, before the creating my cool system I went through intro on RxJS and read many articles</p><p>but I think they all had a flaw - they were just introduction talks or talks about specific problem.</p><p>Maybe I've searched not enough, but all of them were like - hey, dude, come to try Rx, it's fun.</p><p>And you read them and say - yeah, I like that idea, managing my events in a consistent way, cool.</p><p>But then you start using it in your project, or maybe write some kind of system about it and then I've realized I cannot use it at full power</p><p>because I don't completely understand what's going on</p><p>Again, I'm not pro and I'm sure many of you know this is a memory leak, but when you encounter things like this first time,you start researching a bit more and then then you find documentation.</p><p>SPACE</p><p>And then a whole new world opens are you trying to comprehend what's going on.</p><p>Even when I was choosing theme for this talk, me and my collegue were sitting right there, choosing themes and I said I wanna do talk about RxJS</p><p>He asked me - wait, what's so hard about RxJS? I said - oh, so you know it well, he was like - yeah.</p><p>I asked him so you do know what materialize/unmaterialze operators do, he went to the docs and was sitting for like 5 minutes, murmuring</p><p>I was like - ok, I may change and he was like nope.</p></aside></section><section data-timing="60"><h2>.take(0)</h2><!--p.center.big: b .take(0)--><ul><li>a) subscribes/completes/unsubscribes</li><li>b) never emits, never completes</li><li class="fragment hlbg-green">c) doesn't even subscribe, just completes</li></ul><aside class="notes"><p>Here's one practical point I've learned while making this:</p><p>operators are pure functions and while they don't affect any upstream observable, they can do whatever they want with underlying.</p><p>And therefore you need understand what they do very clear. Even if we talk about easy operators.</p><p>I.e. let's look at .take operator with zero - can you tell what it does? a,b,c</p><p>The answer is C, but how do you know it?</p><p>Well, either you read about it somewhere outside of documentation or you go check sources.</p><p>and sources look like this:</p></aside></section><section data-timing="30"><h2>.take source code</h2><div class="pre"><code>function take(count) {
  return (source: Observable) => {
    <span class="ahlbg-blue-w">if (count === 0) {</span>
      <span class="ahlbg-blue-w">return empty()</span>;
    } else {
      return source.lift(new TakeOperator(count));
    }
  };
}</code></div><div class="fragment"><div class="pre"><code>class TakeOperator<T> implements Operator<T, T> {
  ...
  call(subscriber: Subscriber, source: Observable) {
    return source.subscribe(new TakeSubscriber(subscriber, this.total));
  }
}</code></div></div><div class="fragment"><div class="pre"><code>class TakeSubscriber<T> extends Subscriber<T> {
  protected <span class="ahlbg-orange">_next</span>(value: T): void {
    ...
    if (count <= total) {
      this.destination.next(value);
      if (count === total) {
        this.destination.complete();
        this.unsubscribe();
      }
    }
  }
}</code></div></div><aside class="notes"><p>so on creation, it checks the count and returns empty observable if you're providing 0</p><p>but if it's not zero, it subscribes to the source observable and uses some kind of internal method with Take Operator</p><p>SPACE</p><p>This operator looks like this and all it does is subscribes to the source with Subscriber</p><p>SPACE</p><p>And the real stuff is being done in that subscriber which has some internal _next and destination stuff</p><p>There you may stop me and say - hey, why would we need to know about internals? we don't care.</p><p>But I'd answer - i think this is interesting. It will help you to understand and debug operators that you're using</p><p>and it will help you to write your own operators, if you ever need one.</p></aside></section><section data-timing="60"><h2>Really small <span class="smallest">intro</span></h2><p>Observable -> cool value, nice value, happy value -> <span class="fragment hlbg-red-w" data-fragment-index="1">Observer</span></p><div class="bigger"><div class="pre"><code>const observable$ = new Observable(<span class="fragment hlbg-red-w" data-fragment-index="1">subscriber</span> => {
  subscriber.next(1);
  subscriber.complete();
})

observable$.subscribe(<span class="fragment hlbg-red-w" data-fragment-index="1">someObserver</span>);</code></div></div><p class="fragment">Observer is an interface</p><aside class="notes"><p>but, lets start from the beginning</p><p>There's basic example I copied from RxJS website and there's one suspicious thing.</p><p>They talk how we're going to emit values from Observable to Observer when we subscribe, but there's something not right there.</p><p>I'm talking about Subscriber.</p><p>There's no info about subscriber. Meanwhile, it's technically correct - RxJS doesn't have observers, all of them are converted to Subscribers</p><p>And before we get lost between all these names, let's get overview of RX class diagram</p></aside></section></section><section data-timing="60"><section data-timing="60"><h2>RxJS class diagram</h2><img src="img/interfaces1.svg"><aside class="notes"><p>but, lets start from the beginning</p><p>There's basic example I copied from RxJS website and there's one suspicious thing.</p><p>They talk how we're going to emit values from Observable to Observer when we subscribe, but there's something not right there.</p><p>I'm talking about Subscriber.</p><p>There's no info about subscriber. Meanwhile, it's technically correct - RxJS doesn't have observers, all of them are converted to Subscribers.</p></aside></section><section data-timing="60"><h2>RxJS class diagram v2</h2><img src="img/interfaces.svg"></section><section data-timing="60"><h2>RxJS class diagram</h2><ul><li>There're 4 main types: <b>Observable</b>, <b>Subscription</b>, <b>Subscriber</b> and <b>Subject</b></li><li><b>Observable</b> is the simplest one - just a container for subscription logic</li><li><b>Subscription</b> is an object with state and it can hold other Subscriptions</li><li><b>Subscriber</b> is the core class of RxJS, it does all the job</li><li>Subscriber = Subscription + Observer</li><li><b>Subject</b>  is not Observable + Observer, but rather Observable + Subscriber</li></ul></section></section><section><section><h3>Simple example</h3><div class="pre"><code><div class="muted">//step 1</div>const doOnUnsubscribeCallback = () => console.log(`I was unsubscribed`);
const doOnSubscribeCallback = (subscriber) => {
  console.log(`Help me, I was subscribed`);
  subscriber.next(1);
  subscriber.complete();
  return doOnUnsubscribeCallback;
}<div class="muted">// step 2</div>const observable$ = new Rx.Observable(doOnSubscribeCallback);<div class="muted">//observable$ = {
//  _subscribe: doOnSubscribeCallback
//}</div><div class="muted">// step 3</div>observable$.subscribe(makeObserver('John'));</code></div><aside class="notes"><p>Now that you know it, let's look at simple example of Observable workflow.</p><p>3 steps:</p><p>on step one - we're defining callbacks - nothing much happens there</p><p>on step two we're creating Observable and it returns us simple object with our callback set as private _subscribe field</p><p>and all the stuff happens on step 3. let's look closer</p></aside></section><section><h3>Simple subscribe</h3><div class="pre"><code>observable$.subscribe(johnTheObserver) {
  const johnTheSubscriber = convertWhateverWePassIntoSubscriber(johnTheObserver)
  const subscriber = new Subscriber(johnTheSubscriber)
  if (this.operator) { <span class="muted">// this === observable$</span><div class="muted">    subscriber.add(operator.call(subscriber, this.source));</div>  } else {<div class="green">    subscriber.add(this._subscribe(subscriber));</div>  }
  return subscriber;
}</code></div><img src="img/Subscriber.svg" width="600"></section><section><h3>What that means</h3><ul><!--li Observable is an Object: it's either #[code.hljs {_subscribe: function}] or #[code.hljs {source: sourceObservable, operator: someOperator}]--><li>Observable is either just holding our callback or it is some kind of "operator-powered Observable"</li><li>Depending on that it changes behavior when subscribing</li><li>When we subscribe, we convert our Observer to Subscriber, adding state and giving ability to manage subscriptions</li><li class="fragment">when we subscribe we get whole subscriber<div class="biggest"><div class="pre"><code><span class="red">// Don't try this at home!</span>
const obs$ = new Rx.Observable((subscriber) => {});
const subscription = obs$
  .subscribe((value) => console.log(`next(${value})`));
<span class="red">subscription.next('hack'); // outputs next(hack);</span></code></div></div></li></ul></section><section><h3>Operators</h3><img src="img/workflow/operator-setup-title.svg"><br><img class="fragment" src="img/workflow/operator-subscribe-title.svg"><!--.small--><!--  ul--><!--    li what we call the Operator is just an createOperator function (.map)--><!--    h3 on setup:--><!--    li 1. #[b createOperator function] takes projectFunction (x => x) and returns #[b Operation]--><!--    li 2. #[b Operation] takes source Observable and makes that "special operator-powered Observable" by using .lift--><!--    h3 on subscribe:--><!--    li 1. #[b "operator-powered Observable"] calls #[b Operator]--><!--      .massive--><!--        +code.--><!--          #[span.muted // somewhere in observable.subscribe()...]--><!--          const {operator, source} = this; // this === observable--><!--          subscriber.add(operator.call(subscriber, source));--><!----><!--    li 2. #[b Operator] subscribes to the source with it's own #[b OperatorSubscriber].--><!--      br--><!--      | And sets #[b OperatorSubscriber].destination to the passed subscriber;--></section><section><h3>Operators are:</h3><ul><li>OperatorCreator functions:<code class="hljs">(project) => Operation</code></li><li>Operation functions:<code class="hljs">(source: Observable) => Observable</code></li><li>Operators itself:<code class="hljs">(subscriber, source: Observable) =><br>&nbsp;&nbsp;source.subscribe(new Subscriber(subscriber))</code></li></ul></section><section><h3>Brace yourself</h3><div class="center"><img src="img/nedstark.jpg"></div></section><section><h3>Subscribe with operators<div class="fragment replace-out"><img src="img/workflow/subscribe1.svg"></div><div class="fragment replace-in-out"><img src="img/workflow/subscribe2.svg"></div><div class="fragment replace-in-out"><img src="img/workflow/subscribe3.svg"></div><div class="fragment replace-in-out"><img src="img/workflow/subscribe4.svg" height="600"></div><div class="fragment fade-in"><img src="img/workflow/subscribe5.svg" height="600"></div></h3></section><section><h3>Yay!</h3><ul class="fragment"><li>Observables are chained through the .source field up to the <b>onSubscribe</b> callback</li><li><b>.subscribe</b> creates chain of Subscribers</li><li>It's up to every <b>Subscriber</b> in the chain whether to call next of the <b>destination Subscriber</b></li><li>But every <b>destination Subscriber</b> holds his upstream brothers in it's subscription list to consistently unsubscribe.</li></ul></section></section><!--include slides/PushPull--><!--include slides/ObserverPattern--><!--include slides/tasks/param-pam-pam--><!--include slides/3Observable--><!--include slides/tasks/share--><section data-menu-title="conclusion"><section><h2>Conclusion</h2><p>Now you can:</p><ul><li>Debug via looking inside Observables and stuff</li><li>Look into Rx.operators source code without fear</li><li>Write your own Operators with their own Subscribers</li><li>Keep sanity while reading docs</li></ul></section><section><h2>Thanks! You can find this presentation at http://ivan-work.github.io/prxjs</h2><p>sources:</p><ul><li>https://github.com/ReactiveX/rxjs/tree/6.x</li><li>https://rxjs-dev.firebaseapp.com/</li><li>[ru] https://www.youtube.com/watch?v=7806msvJ1HE - Cool presentation about memory leaks</li><li>https://medium.com/angular-in-depth</li></ul></section></section><!--include slides/observables-advanced-->
  </div>
</div>
<script type="text/javascript" src="main.js"></script></body>
</html>