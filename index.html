<html>
<head>
  <meta charset="utf-8"/>
  <title>PRXJS</title>
  <link href="css/fonts/fonts.css" rel="stylesheet"/>
<link href="css/main.css" rel="stylesheet"></head>
<body>
<div class="reveal">
  <div class="slides">
    <section data-menu-title="Introduction"><section data-timing="30"><h1>Anatomy of Rx</h1><aside class="notes"><p>Hello! Today I'd like to talk about Observables and RxJS</p><p>Here, I'll try to help you intuitively understand how RxJS works so you'll feel more comfortable using it</p></aside></section><section data-timing="30"><h2>Why?</h2><ul><li>.map and .subscribe are fun!</li><li class="fragment">reading this is not fun:<code class="hljs smaller">Maps each source value to the given Observable innerObservable regardless of the source value, and then flattens those resulting Observables into one single Observable, which is the output Observable.

The output Observables emits values only from the most recently emitted instance of innerObservable.

<div class="right small">Â© .switchMapTo API documentation</div>
</code></li></ul><aside class="notes"><p>I think it's hard to fully utilize Rx without knowledge of how it works internally</p><p>Yeah, it's all fine when you're just mapping and subscribing</p><p>2. But if you'll ever need to step aside from simple logic or dare to go to documentation</p><p>it could be quite difficult to handle all of Rx's power</p></aside></section><section data-timing="30"><h2>The plan</h2><ul class="big"><li class="fragment">Overview</li><li class="fragment">Rx.Observable structure and flow</li><li class="fragment">Dispel some magic</li></ul><aside class="notes"><p>So, here's what we're going to do</p><p>We're going to have a short overview of what is Observable and RxJS to make sure everyone is on the same page.</p><p>Next we'll look how Rx.Observable looks like in the source code</p><p>Explain some non-obvious behavior examples</p><p>Let's go:</p></aside></section></section><section><section data-menu-title="Overview"><h2>What is ReactiveX</h2><div class="sided-no-bg">ReactiveX combines the Observer pattern with the Iterator pattern and functional programming with collections to fill the need for an ideal way of managing sequences of events.</div><aside class="notes"><p>#todo somehow lead to the next slide</p><p>Reactive programming is blablabla #todo</p></aside></section><section><h2>Observer pattern sequence</h2><p class="sided-no-bg smaller">In the Observer pattern, the <b>subject</b> maintains a list of its dependents, called <b>observers</b>, and notifies them automatically of any state changes</p><img src="img/Overview-Observer.svg"><aside class="notes"><p>Let's take a look at observer pattern sequence diagram. I copied from wiki.</p><p>It's pretty simple</p><p>There's a subject, and two observers. They attach to the subject, then something happens and after that subject notifies them</p><p>now let's look at Rx flow</p></aside></section><section><h2>Rx.Subject sequence</h2><img src="img/Overview-RxSubject.svg"><aside class="notes"><p>Here is the Rx flow and as we see - in pretty much the same, however there's caveat.</p><p>Can you spot it?</p><p>...</p><p>In Rx, you mostly deal with observables. And there's no observable in this diagram, there's Subject and Observers</p><p>and if we take a look at sequence with Observables instead of Subjects, it'll be not so smooth</p></aside></section><section><h2>Rx.Observable</h2><img src="img/Overview-RxObservable.svg"><aside class="notes"><p>Here is how I see it. Observables have subscription function that executes on subscribe.</p><p>In example if you have a button and subscribe to "click" event twice - by default Rx adds two event handlers to the button</p><p>and when you actually do a click - they both fire, each for it's own observers</p><p>also complete and unsubscription flows are represented by that guy #joke</p></aside></section></section><section><section><h2>Push/Pull</h2><div class="center fragment replace-in-out" data-fragment-index="1"><img src="img/producer-consumer.png" width="600"></div><table class="smaller fragment" data-fragment-index="2"><tr><th></th><th><div class="fragment" data-fragment-index="2">Example</div></th><th><div class="fragment" data-fragment-index="2">Producer</div></th><th><div class="fragment" data-fragment-index="2">Consumer</div></th></tr><tr class="fragment" data-fragment-index="2"><th>Pull</th><td><code class="single-line"><span class="red">data</span> = <span class="blue">getData()</span>;</code></td><td class="blue">Passive</td><td class="red">Active</td></tr><tr class="fragment" data-fragment-index="3"><th>Push</th><td><code class="single-line fragment replace-in-out" data-fragment-index="3"><span class="red">dataProducer()</span></code><code class="single-line fragment replace-in" data-fragment-index="4">dataProducer() <em class="muted">//</em><em class="red">internal stuff</em></code><br><code class="single-line">  .onData(<span class="blue">reactToData</span>);</code></td><td class="red">Active</td><td class="blue">Passive</td></tr></table><div class="fragment smaller" data-fragment-index="5"><br><code>anyPromise() <em class="muted">//</em><em class="red">resolve()</em>
<br>
&nbsp;&nbsp;.then((data) => <span class="blue">doSomething</span>(data))</code></div><aside class="notes"><p>to understand why it is like this, let's go back a bit and talk about push and pull approach</p><p>Imagine some abstract code logic</p><p>We can split it to Producers parts and Consumers parts so it works like this:</p><p>1. We have some value and it flows from Producer to Consumer</p><p>We can make it work with two different approaches - Pull and Push.</p><p>2. Pull is a traditional, imperative approach = we request or pull data when we need it</p><p>Producer is passive here - it produces data when requested</p><p>And Consumer is active - it decides when data is requested</p><p>3. In Push systems, the Producer determines when to send data to the Consumer, it's Active</p><p>The Consumer is unaware of when it will receive that data - it's Passive</p><p>And that's too simple, I want to be precise here - dataProducer() is not "requesting a data" when called - it's merely defines the producer. And that producer determines by iteself whenever to call the callback, so actually it should look like this 4.
</p><p>5. A good example of Push-based approach is a Promise</p><p>Ok, but what if we have not single, but multiple values?</p></aside></section><section data-menu-title="Push/Pull over single/multiple values"><h3>Push/pull over single/multiple values</h3><!--p.sided-no-bg.fragment.replace-in(data-fragment-index=4) #[em Pull] and #[em Push] are two different protocols that describe how a data #[em Producer] can communicate with a data #[em Consumer].--><table class="small"><tr><th></th><th>Single</th><th><div class="fragment" data-fragment-index="3">Multiple</div></th></tr><tr><th>Pull</th><td>Function&lt;value&gt;</td><td><div class="fragment" data-fragment-index="3">Iterator&lt;values&gt;</div></td></tr><tr><th>Push</th><td>Promise&lt;value&gt;</td><td><div class="fragment" data-fragment-index="4">Observables&lt;values&gt;</div></td></tr></table><aside class="notes"><p>I just explained single values - in Pull it's a function call and in Push it's a promise.</p><p>For pulling multiple values we can use iterator</p><p>And, finally, when we want to work with multiple values via push-based approach, we may use Observables</p><p>So based on this table we may define Observables as "A way to iterate over multiple values by Push approach"</p></aside></section></section><section><section data-menu-title="Observable"><h3>The concept of Observable</h3><div class="fragment sided-no-bg" data-fragment-index="1">Observables are the way of organizing series of events</div><div class="fragment replace-in-out bigger" data-fragment-index="2"><div class="pre javascript"><code>// traditional
document.addEventListener('keydown', () =>
  console.log('Key down!'));
// reactive
Rx.Observable.fromEvent(document, 'keydown')
  .subscribe(() => console.log('Key down!'));</code></div></div><div class="fragment fade-in big" data-fragment-index="3"><div class="pre javascript"><code>const input$ = Rx.fromEvent(document, 'keydown')
  <div class="fragment replace-in-out" data-fragment-index="3">.pipe(pluck('key'), share());</div><div class="fragment replace-in" data-fragment-index="4">.pipe(<span class="red">pluck('key')</span>, <span class="red">share()</span>);</div>

<span class="fragment replace-out" data-fragment-index="5">input$.subscribe</span><span class="fragment replace-in blue" data-fragment-index="5">input$.subscribe</span>(key => outputNicely(key));

<span class="fragment replace-out" data-fragment-index="5">input$</span><span class="fragment replace-in blue" data-fragment-index="5">input$</span>.pipe(
  <div class="fragment replace-in-out" data-fragment-index="3">bufferCount(5, 1)</div><span class="red fragment replace-in" data-fragment-index="4">bufferCount(5, 1)</span>
  , <div class="fragment replace-in-out" data-fragment-index="3">filter(buffered => buffered.join('') === 'param')</div><span class="red fragment replace-in" data-fragment-index="4">filter(buffered => buffered.join('') === 'param')</span>
)<span class="fragment replace-out" data-fragment-index="5">.subscribe</span><span class="fragment replace-in blue" data-fragment-index="5">.subscribe</span>(keys => outputNicely('PAM PAM'))</code></div></div><aside class="notes"><p>#todo fix + simplify colors</p><p>but to make more sense, I'd say - Observables are the way of organizing series of events 1.</p><p>Here I'd like to address one thing - many introductions to Rx show this code 2. as example of Rx benefits</p><p>I think that this is a bit misleading, because there's no real benefit or organisation going on when using Observables just to subscribe for document events</p><p>If i was writing introduction to observable, I'd give this code as example</p><p>3. Yes, it's a bit complicated, but here we have all the main points</p><p>4. We actually show that we can map observables</p><p>5. Also we show that with observables, we can "Organize multiple events" - if we need keypress event to do two separate things, we can do it easily</p><p>Let's look at this example live</p></aside></section><section data-capture="1"><h2>Practice!</h2><div class="pre javascript"><code>const input$ = Rx.fromEvent(document, 'keydown')
 .pipe(pluck('key'), share());

input$.subscribe(key => outputNicely(key));

input$.pipe(
  bufferCount(5, 1)
  , filter(buffered => buffered.join('') === 'param')
).subscribe(keys => outputNicely('PAM PAM'))</code></div><div id="parampampam" style="height: 200px"><p>type 'param':</p><div id="pam"></div><div id="pampam"></div></div><aside class="notes"><p>We have same code here, and if I press some keys it'll output them: QWEQWE</p><p>and we want it to out "pam pam" whenever we type 'param'</p><p>This is not rocket science, but still quite complex behavior that we were able to achieve in seven lines of code</p></aside></section><section data-menu-title="#todo possibly remove"><div class="small"><div class="pre javascript"><code>const pam = document.getElementById('pam');
const pampam = document.getElementById('pampam');
const input$ = Rx.fromEvent(document, 'keydown', true)
  .pipe(
    <span class="green-dark">op.filter(() => Reveal.getCurrentSlide().getAttribute('data-capture'))</span>
    <span class="green-dark">, op.filter(({keyCode}) => 65 <= keyCode && keyCode <= 90)</span>
    <span class="green-dark">, op.tap(e => e.stopImmediatePropagation())</span>
    , op.pluck('key')
    , op.share()
  );

input$.subscribe(key => {
  createFadingElement(pam, key);
});

input$.pipe(
  op.bufferCount(5, 1)
  , op.filter(buffered => buffered.join('') === 'param')
)
  .subscribe(e => {
    createFadingElement(pampam, 'PAM-PAM!');
})</code></div></div><aside class="notes"><p>??? Well, to be honest, I cheated a bit, here's real and full code to make this example work:</p><p>In green code I'm taking keyboard controls away from my presentation library</p></aside></section></section><section><section><h2>Rx.Observable</h2><p class="sided-no-bg fragment fade-in-then-semi-out">A representation of any set of values over any amount of time. This is the most basic building block of RxJS</p><div class="fragment fade-in-then-out"><!--+js.--><!--  p Maps each source value to the given Observable innerObservable regardless of the source value, and then flattens those resulting Observables into one single Observable, which is the output Observable. The output Observables emits values only from the most recently emitted instance of innerObservable.--><!--  p.right.small Â© .switchMapTo API documentation--><code class="hljs smaller">Maps each source value to the given Observable innerObservable regardless of the source value, and then flattens those resulting Observables into one single Observable, which is the output Observable.

The output Observables emits values only from the most recently emitted instance of innerObservable.

<div class="right small">Â© .switchMapTo API documentation</div></code></div><aside class="notes"><p>After we saw what is the point of observables, let's dive deeper into ReactiveX</p><p>The most basic building block of Rx is, of course, Observable - A representation of any set of values over any amount of time.</p><p>#todo get another example? remove?</p><p>1. I advise you to remember it well.</p><p>Do you recall that example from documentation?</p><p>First advice - if you ever feel dizzy reading this - you may remember than Observable is just a set of values over time and starting from that ground work your way to parse this</p><p>Let's start from basics</p></aside></section><section><h2>Observable workflow</h2><div class="mermaid" data-width="600" data-height="300"><div class="mermaid-in">graph TD
subscribeFn(Subscribe function) ==> createObservable(Observable)
unsubscribeFn(Unsubscribe function) ==> createObservable(Observable)
createObservable --> Observer</div><div class="mermaid-out"></div></div></section><section><h2>Observable class</h2><div class="pre javascript"><code>class Rx.Observable {
  private _isScalar: boolean
  private source: Observable
  private operator: Operator

  constructor(subscribeFunction) {...}
  lift(operator) {...}
  subscribe(observer) {...}
  pipe(observer) {...}
}</code></div><!--+mermaid(w=200 h=200 s=2).classDiagram
class Observable {
   _isScalar: boolean
  source: Observable
  operator: Operator
  constructor ( SubscribeFn )
  lift ( Operator )
  subscribe ( Observer )
  pipe ( Observer )
}--><aside class="notes"><p>Let's take a look what is this "basic building block".</p><p>I've tried to distill this as much as possible and here's what I have.</p><p>Let's start from constructor</p></aside></section><section><div class="pre javascript"><code>export class Observable&lt;T> implements Subscribable&lt;T> {
  public _isScalar: boolean = false;
  source: Observable&lt;any>;
  operator: Operator&lt;any, T>;

  constructor(subscribe) {
    this._subscribe = subscribe;
  }

  lift&lt;R>(operator: Operator&lt;T, R>): Observable&lt;R> {
    const observable = new Observable&lt;R>();
    observable.source = this;
    observable.operator = operator;
    return observable;
  }

  subscribe(sink: Observer) {
    if (this.operator) {
      sink.add(this.operator(this.source));
    } else {
      sink.add(this.source || this._subscribe(sink))
    }
    return sink;
  }

  _subscribe(subscriber: Subscriber): TeardownLogic {
    const {source} = this;
    return source && source.subscribe(subscriber);
  }

  pipe(...operations: OperatorFunction)
}</code></div></section><section><h2>Operators</h2><!--+mermaid.--><!--  graph LR--><!--  style O1 stroke-dasharray: 5, 5--><!--  style O2 stroke-dasharray: 5, 5--><!----><!--  O1(Observable) ==> op(Operator)--><!--  op ==> O2(Observable)--><p>lift</p><p>not pure functions</p></section><section><h2>.pipe()</h2><p>used to avoid spoiling Observable.prototype.</p><div class="pre javascript"><code>const pipe = (...mapFunctions) => mapFunctions
  .reduce((observable, mapFunction) => mapFunction(observable));</code></div></section></section><section data-menu-title="Advanced Observables"><section><h2>Obligatory Cold vs Hot</h2><p>cold > hot</p><p>hot > cold</p><p>real life examples</p></section><section><div class="pre javascript"><code>const observer = (name) => ({
  next: (value) => log(`observer[${name}].next(${value})`),
  complete: () => log(`observer[${name}].complete()`)
});

const oneTwo$ = Rx.Observable.create((subscriber) => {
  subscriber.next(1);
  subscriber.next(2);
  <span class="fragment replace-in" data-fragment-index="3"><span class="bg-warning">subscriber.complete();</span></span>
}).pipe(share());

oneTwo$.subscribe(observer('a'));
oneTwo$.subscribe(observer('b'));</code></div><div class="fragment replace-in" data-fragment-index="1"><div class="fragment replace-out" data-fragment-index="2"><div class="pre javascript"><code>// observer[a].next(1)
// observer[a].next(2)</code></div></div></div><div class="fragment fade-in"><div class="pre javascript"><code>// observer[a].next(1)
// observer[a].next(2)
// observer[a].complete()
// observer[b].next(1)
// observer[b].next(2)
// observer[b].complete()</code></div></div></section><section><p>#todo explanation</p></section></section><!--include tasks/slot-machine-type.pugsection
  +js.
    const button = document.querySelector('button');
    button.addEventListener('click', () => console.log('Clicked!'));
  +js.
    var button = document.querySelector('button');
    Rx.Observable.fromEvent(button, 'click').subscribe(() => console.log('Clicked!'));-->
  </div>
</div>
<script type="text/javascript" src="main.js"></script></body>
</html>