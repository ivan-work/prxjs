<html>
<head>
  <meta charset="utf-8"/>
  <title>PRXJS</title>
  <link href="css/fonts/fonts.css" rel="stylesheet"/>
<link href="css/main.css" rel="stylesheet"></head>
<body>
<div class="reveal">
  <div class="slides">
    <section data-menu-title="Introduction"><section data-timing="20"><h1>Anatomy of RxJS</h1><aside class="notes"><p>Hello!</p><p>My name is Ivan Naimark, I am react/nodejs developer here, at Grid Dynamics.</p><p>Today I'd like to talk about RxJS.</p></aside></section><section data-timing="60"><h2>My story</h2><ul><li>RxJava was cool&nbsp;<img src="img/doge.png" height="100" valign="middle"></li><li class="fragment">AngularJS / React doesn't have RxJS</li><li class="fragment">Pet-projects<br><!--img.fragment.replace-in-out(src='img/pepe.png' height=400)--><img class="fragment" src="img/stackoverflow.png" height="300"></li></ul><!--.fragment.center: img(src='img/stackoverflow.png' width=800)--><aside class="notes"><p>Let me tell you my story:</p><p>So my first encounter with Rx happened when I was Android developer and it was RxJava</p><p>I'm not sure what's happening in mobile right now, but back in my days it was very verbose.</p><p>You were writing abstract factories of thread pools, do all the stuff imperatively, painfully switch threads, so when I went to a project with RxJava I liked it.</p><p>even though it burned my brains a bit, I took a notice - wow, reactive style is cool, but hard</p><p>Then I switched to javascript, learned Angualr 1 and React and kinda forgot about it.</p><p>When angular 2 came out I decided to skip it because I like React. Not going to holy war, it's just me</p><p>However, I like to make hobby projects, like bots, games, fun stuff and usually, the logic in them is a bit more complex than in our enterprise webapps.</p><p>y know, show this table, show that table, if something is wrong, blame backend :)</p><p>So, for my next multiplayer game I've decided to use RxJS, because events, async stuff and I wanted actors all over the place...</p><p>and then it hit me hard.</p><p>SPACE</p><p>It was so hard to manage it and actually make it do what I want. I'm talking about logic like this - real screenshot of my question</p><p>I won't go explaining what I'm trying to achieve here, the main point is -</p><p>when I went beyond simple requests and tried to utilize all power to achieve what I want - it was hard.</p><p>And all the online resources didn't help me - it were either introductions or, like, deep dives that even show you how to create custom operators</p><p>but they were not explaining why its working and how it's happening.</p><p>therefore this presentation was born - I decided to deep dive myself and go to the sources.</p></aside></section><section data-timing="30"><h2>Introductions</h2><ul><li>.maps and .subscribes are fun!</li><li class="fragment">.takeUntil is less fun:<div class="bigger"><div class="pre"><code>someDataStream$.pipe(
  takeUntil(componentUnmount$),
  merge(someEvent1$, someEvent2$)
)</code></div></div></li><li class="fragment">reading this is not fun at all:<div class="small"><code class="hljs">Maps each source value to the given Observable innerObservable regardless of the source value, and then flattens those resulting Observables into one single Observable, which is the output Observable.

The output Observables emits values only from the most recently emitted instance of innerObservable.

<div class="right small">Â© .switchMapTo API documentation</div></code></div></li></ul><aside class="notes"><p>Of course, before the creating my cool system I went through intro on RxJS and read many articles</p><p>but I think they all had a flaw - they were just introduction talks or talks about specific problem.</p><p>Maybe I've searched not enough, but all of them were like - hey, dude, come to try Rx, it's fun.</p><p>And you read them and say - yeah, I like that idea, managing my events in a consistent way, cool.</p><p>But then you start using it in your project, or maybe write some kind of system about it and then I've realized I cannot use it at full power</p><p>because I don't completely understand what's going on</p><p>Again, I'm not pro and I'm sure many of you know this is a memory leak, but when you encounter things like this first time,you start researching a bit more and then then you find documentation.</p><p>SPACE</p><p>And then a whole new world opens are you trying to comprehend what's going on.</p><p>Even when I was choosing theme for this talk, me and my collegue were sitting right there, choosing themes and I said I wanna do talk about RxJS</p><p>He asked me - wait, what's so hard about RxJS? I said - oh, so you know it well, he was like - yeah.</p><p>I asked him so you do know what materialize/unmaterialze operators do, he went to the docs and was sitting for like 5 minutes, murmuring</p><p>I was like - ok, I may change and he was like nope.</p></aside></section><section data-timing="60"><h2>.take(0)</h2><p class="sided">Emits only the first count values emitted by the source Observable.</p><ul><li>a) subscribes/completes/unsubscribes</li><li>b) never emits, never completes</li><li class="fragment hlbg-green">c) doesn't even subscribe, just completes</li></ul><aside class="notes"><p>Here's one practical point I've learned while making this:</p><p>operators are pure functions and while they don't affect any upstream observable, they can do whatever they want with underlying.</p><p>And therefore you need understand what they do very clear. Even if we talk about easy operators.</p><p>I.e. let's look at .take operator with zero - can you tell what it does? a,b,c</p><p>The answer is C, but how do you know it?</p><p>Well, either you read about it somewhere outside of documentation or you go check sources.</p><p>and sources look like this:</p></aside></section><section data-timing="30" data-menu-title=".take source code"><div class="pre"><code>function take(count) {
  return (source: Observable) => {
    <span class="ahlbg-blue-w">if (count === 0) {</span>
      <span class="ahlbg-blue-w">return empty()</span>;
    } else {
      return source.lift(new TakeOperator(count));
    }
  };
}</code></div><div class="fragment small"><div class="pre"><code>class TakeOperator<T> implements Operator<T, T> {
  call(subscriber: Subscriber, source: Observable) {
    return source.subscribe(<span class="ahlbg-orange">new TakeSubscriber</span>(subscriber, this.total));
  }
}</code></div><div class="pre"><code>class TakeSubscriber<T> extends Subscriber<T> {
  protected <span class="ahlbg-orange">_next</span>(value: T): void {
    if (count <= total) {
      this.<span class="ahlbg-orange">destination</span>.next(value);
      if (count === total) {
        this.destination.complete();
        this.unsubscribe();
      }
    }
  }
}</code></div></div><aside class="notes"><p>so on creation, it checks the count and returns empty observable if you're providing 0</p><p>but if it's not zero, it subscribes to the source observable and uses some kind of internal method with Take Operator</p><p>SPACE</p><p>This operator looks like this and all it does is subscribes to the source with Subscriber</p><p>SPACE</p><p>And the real stuff is being done in that subscriber which has some internal _next and destination stuff</p><p>There you may stop me and say - hey, why would we need to know about internals? we don't care.</p><p>But I'd answer - i think this is interesting. It will help you to understand and debug operators that you're using</p><p>and it will help you to write your own operators, if you ever need one.</p></aside></section><section data-timing="60"><h2>Really small <span class="smallest">intro</span></h2><br><p class="center sided-no-bg">Observable -> ...values... -> <span class="fragment hlbg-green-w" data-fragment-index="1">Observer</span></p><br><div class="left fragment replace-in"><p class="sided">Observer is a public interface</p><br></div><div class="bigger"><div class="pre"><code>const observable$ = new Observable(<span class="fragment hlbg-red-w" data-fragment-index="1">subscriber</span> => {
  subscriber.next(1);
  subscriber.complete();
})

observable$.subscribe(<span class="fragment hlbg-green-w" data-fragment-index="1">someObserver</span>);</code></div></div><br><aside class="notes"><p>but, lets start from the beginning</p><p>There's basic example I copied from RxJS website and there's one suspicious thing.</p><p>They talk how we're going to emit values from Observable to Observer when we subscribe, but there's something not right there.</p><p>I'm talking about Subscriber.</p><p>There's no info about subscriber. Meanwhile, it's technically correct - RxJS doesn't have observers, all of them are converted to Subscribers</p><p>And before we get lost between all these names, let's get overview of RX class diagram</p></aside></section></section><section data-timing="60"><section data-timing="60"><h2>RxJS class diagram</h2><svg class="absolute full"><!--rect.fragment.outline.red(style='width: 400px; height: 400px; ')--><rect class="outline fragment replace-in-out" x="2" y="2" width="560" height="70"></rect><rect class="outline fragment replace-in-out" x="620" y="2" width="140" height="110"></rect><rect class="outline fragment replace-in-out" x="310" y="310" width="260" height="140"></rect><rect class="outline fragment replace-in-out" x="310" y="110" width="260" height="150"></rect><rect class="outline fragment replace-in-out" x="2" y="110" width="260" height="130"></rect><rect class="outline fragment replace-in-out" x="2" y="310" width="260" height="110"></rect></svg><img class="margin" src="img/interfaces.svg"><aside class="notes"><p>but, lets start from the beginning</p><p>There's basic example I copied from RxJS website and there's one suspicious thing.</p><p>They talk how we're going to emit values from Observable to Observer when we subscribe, but there's something not right there.</p><p>I'm talking about Subscriber.</p><p>There's no info about subscriber. Meanwhile, it's technically correct - RxJS doesn't have observers, all of them are converted to Subscribers.</p></aside></section><!--section(data-timing=60)--><!--  h2 RxJS class diagram--><!--  svg.absolute.full--><!--  img(src='img/interfaces.svg')--><section data-timing="60"><h2>RxJS class diagram</h2><p>3 main types:</p><ul><li><b>Observable</b>: holds stuff</li><li><b>Subscription</b>: Manages unsubscription logic</li><li><b>Subscriber</b>: <b>Subscription</b> + <b>Observer</b>, it does all the job</li><li>All of them form "chains"</li></ul></section></section><section><section><h3>Simple example</h3><div><div class="pre"><code><div class="muted">//step 1</div>const doOnUnsubscribeCallback = ...
const doOnSubscribeCallback = ...<div class="muted">// step 2</div>const observable$ = new Rx.Observable(doOnSubscribeCallback);<div class="muted">//observable$ = {
//  _subscribe: doOnSubscribeCallback
//}</div><div class="muted">// step 3</div>observable$.subscribe(someObserver);</code></div></div><aside class="notes"><p>Now that you know it, let's look at simple example of Observable workflow.</p><p>3 steps:</p><p>on step one - we're defining callbacks - nothing much happens there</p><p>on step two we're creating Observable and it returns us simple object with our callback set as private _subscribe field</p><p>and all the stuff happens on step 3. let's look closer</p></aside></section><section><h3>Simple subscribe</h3><div class="pre"><code>observable$.subscribe(whatever) {
  const subscriber = toSubscriber(whatever)
  if (this.operator) { <span class="muted">// this === observable$</span><div class="muted">    subscriber.add(operator.call(subscriber, this.source));</div>  } else {<div class="green">    subscriber.add(this._subscribe(subscriber));</div>  }
  return subscriber;
}</code></div><div class="fragment replace-out"><div class="pre javascript"><code>const toSubscriber = (whatever) => {
  if (whatever instanceof Subscriber) {
    return whatever;
  } else {
    return new Subscriber(whatever);
  }
}</code></div></div><img class="fragment fade-in" src="img/Subscriber.svg" width="600"></section><section><h3>What that means</h3><ul><!--li Observable is an Object: it's either #[code.hljs {_subscribe: function}] or #[code.hljs {source: sourceObservable, operator: someOperator}]--><li>Two types of Observable:<br>1: Holds callback<br>2: "Operator Observable" - holds Operator and link to the source Observable</li><li>When we subscribe, we convert our Observer to Subscriber, adding state and giving ability to manage subscriptions</li><li>.subscribe returns whole Subscriber<div class="bigger fragment"><div class="pre"><code><span class="red">// Don't try this at home!</span>
const obs$ = new Rx.Observable((subscriber) => {});
const subscription = obs$
  .subscribe((value) => console.log(`next(${value})`));
<span class="red">subscription.next('hack'); // outputs next(hack);</span></code></div></div></li></ul></section><section><h3>Setup with Operators</h3><img src="img/workflow/operator-setup-title.svg"></section><section><h3>Subscribe with Operators</h3><img src="img/workflow/operator-subscribe-title.svg" height="200"><div class="pre"><code>observable$.subscribe(whatever) {
  const subscriber = toSubscriber(whatever)
  if (this.operator) { <span class="muted">// this === observable$</span><div class="green">    subscriber.add(operator.call(subscriber, this.source));</div>  } else {<div class="muted">...</div></code></div><div class="small"><div class="pre javascript"><code>class MapOperator<T> implements Operator<T, T> {
  call(subscriber: Subscriber, source: Observable) {
    return source.subscribe(new MapSubscriber(subscriber, ...));
  }
}</code></div></div></section><section><h3>Operators are:</h3><ul><li>OperatorCreator functions:<code class="hljs">(project) => Operation</code></li><li>Operation functions:<code class="hljs">(source: Observable) => Observable</code></li><li>Operators itself:<code class="hljs">(subscriber, source: Observable) =><br>&nbsp;&nbsp;source.subscribe(new Subscriber(subscriber))</code></li></ul></section><section><h3>Brace yourself</h3><div class="center"><img src="img/nedstark.jpg"></div></section><section><h3>Subscribe with operators<div class="fragment replace-out"><img src="img/workflow/subscribe1.svg"></div><div class="fragment replace-in-out"><img src="img/workflow/subscribe2.svg"></div><div class="fragment replace-in-out"><img src="img/workflow/subscribe3.svg"></div><div class="fragment replace-in-out"><img src="img/workflow/subscribe4.svg" height="600"></div><div class="fragment fade-in"><img src="img/workflow/subscribe5.svg" height="600"></div></h3></section><section><h3>Yay!</h3><ul class="fragment"><li>Observables are chained through the .source</li><li>Subscribers are chained through the .destination</li><li>Unsubscription logic is backward-chained through Subscribers</li></ul></section></section><!--include slides/PushPull--><!--include slides/ObserverPattern--><!--include slides/tasks/param-pam-pam--><!--include slides/3Observable--><!--include slides/tasks/share--><section data-menu-title="conclusion"><section><h2>Conclusion</h2><p class="center">Now you can:</p><ul><li>debug</li><li>check Operators' source code</li><li>write your own Operators</li><li>read docs</li></ul></section><section><h2>Thanks!</h2><p>You can find this presentation at</p><p class="sided">http://ivan-work.github.io/prxjs</p><p>sources:</p><ul class="smaller"><li>https://github.com/ReactiveX/rxjs/tree/6.x</li><li>https://rxjs-dev.firebaseapp.com/</li><li>[ru] https://www.youtube.com/watch?v=7806msvJ1HE</li><li>https://medium.com/angular-in-depth</li></ul></section></section><!--include slides/observables-advanced-->
  </div>
</div>
<script type="text/javascript" src="main.js"></script></body>
</html>