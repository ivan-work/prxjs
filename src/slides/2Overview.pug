section
  section(data-menu-title="Overview")
    h2 Observer pattern sequence
    p.sided-no-bg.smaller In the Observer pattern, the #[b subject] maintains a list of its dependents, called #[b observers], and notifies them automatically of any state changes
    +mermaid(w=650 h=400 s=1).
      sequenceDiagram
        participant S as Subject
        participant o1 as Observer 1
        participant o2 as Observer 2

        o1 ->> S: attach()
        activate o1
        o2 ->> S: attach()
        activate o2
        Note over S: something happens
        S ->> o1: notify()
        deactivate o1
        S ->> o2: notify()
        deactivate o2
    aside.notes
      p Here we have basic Observable pattern I copied from wiki.
      p #todo read quote?
      p There's a subject, and two observers. They attach to the subject, then something happens and after that subject notifies them
      p now let's look at Rx flow

  section
    h2 ReactiveX sequence
    +mermaid(w=650 h=400 s=1).
      sequenceDiagram
        participant S as Observable
        participant o1 as Observer 1
        participant o2 as Observer 2

        o1 ->> S: subscribe()
        activate o1
        o2 ->> S: subscribe()
        activate o2
        Note over S: value
        S ->> o1: next()
        deactivate o1
        S ->> o2: next()
        deactivate o2
    aside.notes
      p Here is the Rx flow and as we see - in general, it's the same
      p I omitted complete events and operators, we will get to that later

  section
    h2 Push/Pull
    .center.fragment.replace-in-out(data-fragment-index=1): img(src='img/producer-consumer.png' width=600)
    table.smallest.fragment(data-fragment-index=2)
      tr
        th
        th: .fragment(data-fragment-index=2) Example
        th.red: .fragment(data-fragment-index=2) Producer
        th.blue: .fragment(data-fragment-index=2) Consumer
      tr.fragment(data-fragment-index=2)
        th Pull
        td: code.single-line #[span.blue data] = #[span.red getData()];
        td.red Passive
        td.blue Active
      tr.fragment(data-fragment-index=3)
        th Push
        td
          code.single-line #[span.red dataProducer()]
          code.single-line   .produce(#[span.blue reactToData]);
        td.red Active
        td.blue Passive
    aside.notes
      p Ok, but what is the concept of Observable? Let's get back a bit and talk about push versus pull approach.
      p #todo Ask Audience?
      p Usually we can divide code logic to Producers and Consumers. So we have a value and it flows from Producer to Consumer (1)
      p We can make it work with two different approaches - Pull and Push.(2)z
      p 2. Pull is a traditional, imperative approach = we request or pull data when we need it
      p Producer is passive here - it produces data when requested
      p And Consumer is active - it decides when data is requested
      p 3. In Push systems, the Producer determines when to send data to the Consumer, it's Active
      p The Consumer is unaware of when it will receive that data - it's Passive
      p Ok, but what if we have not single, but multiple values?

  section(data-menu-title="Push/Pull over single/multiple values")
    h3 Push/pull over single/multiple values
    //p.sided-no-bg.fragment.replace-in(data-fragment-index=4) #[em Pull] and #[em Push] are two different protocols that describe how a data #[em Producer] can communicate with a data #[em Consumer].
    table.small
      tr
        th
        th Single
        th: .fragment(data-fragment-index=3) Multiple
      tr
        th Pull
        td: .fragment(data-fragment-index=1) Function#{'<value>'}
        td: .fragment(data-fragment-index=3) Iterator#{'<values>'}
      tr
        th Push
        td: .fragment(data-fragment-index=2) Promise#{'<value>'}
        td: .fragment(data-fragment-index=4) Observables#{'<values>'}
    aside.notes
      p So we have here Push and Pull approaches. Let's start from single value - to do something with pull approach you have to just call function
      p 1. In push approach you can use Promise 2.
      p For pulling multiple values we can use iterator
      p And finally for pushing multiple values we can use Observables
      p There we come to Rx

  section
    h2 Rx.Observable
    p.sided-no-bg.fragment.fade-in-then-semi-out A representation of any set of values over any amount of time. This is the most basic building block of RxJS
    .fragment.fade-in-then-out.small
      p Maps each source value to the given Observable innerObservable regardless of the source value, and then flattens those resulting Observables into one single Observable, which is the output Observable. The output Observables emits values only from the most recently emitted instance of innerObservable.
      p.right.small Â© .switchMapTo API documentation
    aside.notes
      p Behold, here's Rx.Observable
      p I love this quote, it helps me to keep sanity